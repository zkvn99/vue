<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <!-- Vue 3 CDN -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    .lightgrey {
      background-color: rgba(121, 121, 121, 0.97);
    }
  </style>
</head>
<body>
<div id="step01">
  <h1>nextTick 예제</h1>
  <h3>{{message}}</h3>
  <button @click="updateMessage">메세지 수정</button>
</div>
<div id="step02">
  <h1>LifeCycle 함수 테스트</h1>
  <button @click="show = !show">
    {{ show ? '언마운트' : '마운트' }}
  </button>
  <child-demo v-if="show"></child-demo>
</div>
<script>
  const {
    createApp,
    ref,
    nextTick,
    onBeforeMount,
    onMounted,
    onBeforeUpdate,
    onUpdated,
    onBeforeUnmount,
    onUnmounted
  } = Vue;
  createApp({
    setup() {
      const message = ref('변경 전 메세지');
      const updateMessage = async () => {
        console.log(`변경 전 : ${document.querySelector('#step01 h3').innerText}`)
        // 반응형 상태 변경 -> Vue가 DOM 업데이트를 예약만 한 상태
        message.value = '변경 후';

        // Vue가 실제 DOM 패치를 끝낼때까지 기다렸다가 그 다음 줄을 실행하고 싶을 때 사용
        await nextTick();

        // 반응형 변수의 값이 변경 되어도 DOM 객체의 실제 값은 아직 변경되지 않았음을 관찰 할 수 있음
        // nextTick 호출 이후에는 변경 완료 된 모습을 관찰 할 수 있음
        console.log(`after : ${document.querySelector('#step01 h3').innerText}`)
      };

      return { message, updateMessage }
    }
  }).mount('#step01');

  const ChildDemo = {
    template : `
    <div>
      <button @click="startLoading">로딩 시작</button>
      <button @click="toggleHighlight">하이라이트 토글</button>
      <div ref="contentRef">
        <div v-if="!loadingState">로딩을 준비합니다.</div>
        <div v-else :class="{ lightgrey : isHighlighted }">컨텐츠 표시 중</div>
      </div>
    </div>
    `,
    setup() {
      const loadingState = ref(false);
      const isHighlighted = ref(false);
      const contentRef = ref(null);

      const startLoading = () => {
        loadingState.value = true;
      };
      const toggleHighlight = () => {
        isHighlighted.value = !isHighlighted.value;
      };

      // 컴포넌트가 처음 화면에 붙기 전, 아직 실제 DOM에는 접근 불가, DOM이 필요 없는 초기 설정에 사용
      onBeforeMount(() => {
        console.log('1) onBeforeMount : 아직 DOM에 붙기 전');
      });

      // 첫 렌더링이 끝나고 컴포넌트가 실제 DOM에 삽입 된 직후, ref로 DOM에 접근할 수 있는 시점
      // 초기 데이터 fetch, focus, 높이 측정 등에 주로 사용
      onMounted(() => {
        console.log('2) onMounted : DOM에 삽입 완료');
        console.log('contentRef 초기 텍스트 : ', contentRef.value?.innerText.trim());
      });

      // 반응형 상태가 바뀌어 DOM이 다시 그려지기 직전, 업데이트 전의 상태가 필요할 때 사용
      onBeforeUpdate(() => {
        const prev = contentRef.value?.innerText.trim();
        console.log('3) onBeforeUpdate : 업데이트 전 컨텐츠 ', prev);
      });

      // 반응형 상태 변경이 DOM 업데이트까지 완료 된 후, 변경 된 DOM 기반 후처리가 필요할 때 사용
      onUpdated(() => {
        const now = contentRef.value?.innerText.trim();
        console.log('4) onUpdated : 업데이트 후 컨텐츠 ', now);
      });

      // 타이머(clearInterval), 이벤트 리스너 제거
      onBeforeUnmount(() => {
        console.log('5) onBeforeUnmount : 언마운트 직전 (정리 준비)');
      });

      // 정리작업이 끝났음을 알림
      onUnmounted(() => {
        console.log('6) onUnmounted : 언마운트 완료 (리소스 정리 끝)');
      })

      return {
        loadingState,
        isHighlighted,
        contentRef,
        startLoading,
        toggleHighlight
      }
    }
  };

  const app = createApp({
    setup() {
      const show = ref(true);
      return {show}
    }
  });
  app.component('child-demo', ChildDemo);
  app.mount('#step02');
</script>
</body>
</html>